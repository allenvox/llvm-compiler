### Трансляция стековых переменных, параметров функций и глобальных переменных в LLVM IR

LLVM IR предоставляет различные механизмы для работы с переменными: стековыми (локальными), параметрами функций и глобальными. Все они имеют строгую типизацию и используют указатели и операции работы с памятью.

---

### 1. **Стековые переменные (локальные переменные)**

Локальные переменные функции в LLVM IR представляют собой выделенные блоки памяти на стеке, создаваемые с помощью инструкции `alloca`. Такие переменные существуют только в контексте функции, в которой они объявлены.

#### Пример на C:
```c
void foo() {
    int x = 42;
    x = x + 1;
}
```

#### LLVM IR:
```llvm
define void @foo() {
entry:
  ; Выделение памяти для локальной переменной x
  %x = alloca i32                ; i32* x

  ; Инициализация x = 42
  store i32 42, i32* %x

  ; Загрузка значения x
  %val = load i32, i32* %x

  ; Инкремент x = x + 1
  %inc = add i32 %val, 1
  store i32 %inc, i32* %x

  ret void
}
```

#### Ключевые инструкции:
- **`alloca`**: выделяет память на стеке для переменной (например, `%x = alloca i32`).
- **`store`**: сохраняет значение в память (`store i32 42, i32* %x`).
- **`load`**: загружает значение из памяти (`%val = load i32, i32* %x`).

#### Особенности:
- Каждая стековая переменная существует только во время выполнения функции.
- Управление стеком выполняется автоматически.

---

### 2. **Параметры функций**

Параметры функции передаются в LLVM IR как виртуальные регистры. Если необходимо изменить переданное значение, оно сначала сохраняется в локальную копию с помощью `alloca`.

#### Пример на C:
```c
void foo(int a) {
    int x = a + 1;
}
```

#### LLVM IR:
```llvm
define void @foo(i32 %a) {
entry:
  ; Выделение памяти для параметра a
  %a.addr = alloca i32
  store i32 %a, i32* %a.addr    ; Сохраняем значение %a в память

  ; Выделение памяти для локальной переменной x
  %x = alloca i32

  ; Загрузка значения a
  %a_val = load i32, i32* %a.addr

  ; Вычисление x = a + 1
  %inc = add i32 %a_val, 1
  store i32 %inc, i32* %x

  ret void
}
```

#### Разъяснения:
- Входное значение `%a` — это виртуальный регистр.
- Если требуется работа с указателем на параметр, создается локальный указатель с `alloca`.

---

### 3. **Глобальные переменные**

Глобальные переменные хранятся в статической памяти и доступны из всех функций модуля. Они объявляются с атрибутом `global` и обычно инициализируются на этапе компиляции.

#### Пример на C:
```c
int g = 42;

void foo() {
    g = g + 1;
}
```

#### LLVM IR:
```llvm
@g = global i32 42               ; Глобальная переменная g

define void @foo() {
entry:
  ; Загрузка значения g
  %g_val = load i32, i32* @g

  ; Инкремент g = g + 1
  %inc = add i32 %g_val, 1
  store i32 %inc, i32* @g

  ret void
}
```

#### Особенности:
- Глобальные переменные имеют атрибут `global`, который указывает, что они существуют в области глобальной памяти.
- Доступ к ним осуществляется напрямую через имя переменной (например, `@g`).

#### Инициализация глобальных переменных:
- Неинициализированная переменная: `@g = global i32 0`.
- Инициализированная: `@g = global i32 42`.

---

### 4. **Сравнение переменных**

| Тип переменной    | Особенности                                                      | Пример LLVM IR                            |
|-------------------|------------------------------------------------------------------|-------------------------------------------|
| **Стековая**      | Выделяется в стеке (`alloca`), доступна только в функции.         | `%x = alloca i32`                         |
| **Параметр**      | Передается через регистры, может быть сохранен в память (`alloca`). | `define void @foo(i32 %a)`                |
| **Глобальная**    | Имеет фиксированное место в памяти (`global`), доступна всем функциям. | `@g = global i32 42`                     |

---

### 5. **Локальные массивы и глобальные массивы**

#### Локальные массивы:
```c
void foo() {
    int arr[3];
    arr[0] = 1;
}
```

LLVM IR:
```llvm
define void @foo() {
entry:
  %arr = alloca [3 x i32]            ; локальный массив
  %ptr = getelementptr [3 x i32], [3 x i32]* %arr, i32 0, i32 0
  store i32 1, i32* %ptr
  ret void
}
```

#### Глобальные массивы:
```c
int arr[3] = {1, 2, 3};
```

LLVM IR:
```llvm
@arr = global [3 x i32] [i32 1, i32 2, i32 3]
```

---

### 6. **Передача переменных в функции**

#### Передача параметров по значению:
```c
void foo(int a) {
    int b = a + 1;
}
```

LLVM IR:
```llvm
define void @foo(i32 %a) {
entry:
  %b = alloca i32
  store i32 %a, i32* %b
  ret void
}
```

#### Передача параметров по указателю:
```c
void foo(int *a) {
    *a = 42;
}
```

LLVM IR:
```llvm
define void @foo(i32* %a) {
entry:
  store i32 42, i32* %a
  ret void
}
```

---

### 7. **Особенности размещения памяти**

#### a) `alloca` для локальных переменных:
- Выделяет память для переменной на стеке.
- Переменная существует только в рамках вызова функции.

#### b) Глобальные переменные:
- Размещаются в статической памяти.
- Не освобождаются до завершения программы.

#### c) Передача параметров:
- Параметры передаются через виртуальные регистры, что позволяет эффективно работать с ними в большинстве случаев.
