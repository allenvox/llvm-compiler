### Трансляция массивов в LLVM IR

Массивы в LLVM IR представляют собой агрегатный тип данных. Они описываются как непрерывный блок памяти фиксированного размера, в котором хранятся элементы одного типа. Для работы с массивами используются указатели, операции индексации, загрузки (`load`) и сохранения (`store`).

---

### 1. **Объявление массива в LLVM IR**

Массивы задаются через тип `array [N x <type>]`, где `N` — количество элементов, а `<type>` — тип элементов массива.

Пример на C:
```c
int arr[5];
```

LLVM IR:
```llvm
@arr = global [5 x i32] zeroinitializer  ; глобальный массив из 5 элементов, инициализированный нулями
```

- Массив из 5 элементов типа `i32` создается как глобальная переменная (`global`).
- `zeroinitializer` — начальная инициализация массива нулями.

---

### 2. **Работа с массивами**

#### a) Доступ к элементам массива

Для доступа к элементам массива используются:
- `getelementptr` (GEP) — вычисление адреса элемента.
- `load` — загрузка значения из памяти.
- `store` — сохранение значения в память.

Пример на C:
```c
int arr[5];
arr[2] = 10;
int x = arr[2];
```

LLVM IR:
```llvm
@arr = global [5 x i32] zeroinitializer

entry:
  ; Получение указателя на arr[2]
  %ptr = getelementptr [5 x i32], [5 x i32]* @arr, i32 0, i32 2

  ; Запись значения 10 в arr[2]
  store i32 10, i32* %ptr

  ; Чтение значения из arr[2]
  %val = load i32, i32* %ptr
```

Разбор:
- `getelementptr [5 x i32], [5 x i32]* @arr, i32 0, i32 2`:
  - Первый индекс (`0`) указывает на начало массива.
  - Второй индекс (`2`) — смещение внутри массива.

---

#### b) Инициализация массива

Пример на C:
```c
int arr[3] = {1, 2, 3};
```

LLVM IR:
```llvm
@arr = global [3 x i32] [i32 1, i32 2, i32 3]
```

---

### 3. **Локальные массивы**

Массивы, объявленные внутри функции, размещаются на стеке с помощью инструкции `alloca`.

Пример на C:
```c
void foo() {
    int arr[5];
    arr[1] = 42;
}
```

LLVM IR:
```llvm
define void @foo() {
entry:
  ; Выделение памяти для массива на стеке
  %arr = alloca [5 x i32]

  ; Получение указателя на arr[1]
  %ptr = getelementptr [5 x i32], [5 x i32]* %arr, i32 0, i32 1

  ; Запись значения 42 в arr[1]
  store i32 42, i32* %ptr
  ret void
}
```

---

### 4. **Передача массивов в функции**

#### Передача по указателю

Пример на C:
```c
void process(int arr[5]) {
    arr[0] = 1;
}
```

LLVM IR:
```llvm
define void @process(i32* %arr) {
entry:
  ; Получение указателя на arr[0]
  %ptr = getelementptr i32, i32* %arr, i32 0

  ; Запись значения 1 в arr[0]
  store i32 1, i32* %ptr
  ret void
}
```

Важное замечание:
- Массив передается как указатель на его первый элемент (`i32* %arr`), а не как сам массив.

---

#### Передача по значению (копия массива)

Для передачи массива по значению используется выделение нового блока памяти и копирование данных.

Пример на C:
```c
void process(int arr[3]) {
    int copy[3];
    for (int i = 0; i < 3; i++) {
        copy[i] = arr[i];
    }
}
```

LLVM IR:
```llvm
define void @process(i32* %arr) {
entry:
  ; Выделение памяти для копии массива
  %copy = alloca [3 x i32]

  ; Копирование элементов
  %ptr0 = getelementptr i32, i32* %arr, i32 0
  %ptr1 = getelementptr [3 x i32], [3 x i32]* %copy, i32 0, i32 0
  %val0 = load i32, i32* %ptr0
  store i32 %val0, i32* %ptr1

  ; (копирование других элементов...)
  ret void
}
```

---

### 5. **Циклы и массивы**

Часто массивы используются в сочетании с циклами для итерации по элементам.

Пример на C:
```c
int arr[5];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}
```

LLVM IR:
```llvm
define void @init_array() {
entry:
  ; Выделение памяти для массива
  %arr = alloca [5 x i32]

  ; Инициализация переменной i
  %i = alloca i32
  store i32 0, i32* %i
  br label %loop_condition

loop_condition:
  ; Условие i < 5
  %i_val = load i32, i32* %i
  %cmp = icmp slt i32 %i_val, 5
  br i1 %cmp, label %loop_body, label %exit

loop_body:
  ; arr[i] = i
  %ptr = getelementptr [5 x i32], [5 x i32]* %arr, i32 0, i32 %i_val
  store i32 %i_val, i32* %ptr

  ; Инкремент i
  %next_i = add i32 %i_val, 1
  store i32 %next_i, i32* %i
  br label %loop_condition

exit:
  ret void
}
```

---

### 6. **Многомерные массивы**

LLVM поддерживает многомерные массивы как вложенные одномерные.

Пример на C:
```c
int arr[2][3];
arr[1][2] = 42;
```

LLVM IR:
```llvm
@arr = global [2 x [3 x i32]] zeroinitializer

entry:
  ; Получение указателя на arr[1][2]
  %ptr = getelementptr [2 x [3 x i32]], [2 x [3 x i32]]* @arr, i32 0, i32 1, i32 2

  ; Запись значения 42 в arr[1][2]
  store i32 42, i32* %ptr
```

---

### 7. **Инициализация массивов с использованием метаданных**

LLVM поддерживает использование метаданных для сложных инициализаций массивов.

Пример:
```llvm
@arr = global [4 x i32] [i32 1, i32 2, i32 3, i32 4]
```
