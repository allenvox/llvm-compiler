### Общее описание LLVM IR

**LLVM IR (Intermediate Representation)** — это промежуточное представление программ, используемое LLVM для выполнения анализа, оптимизации и генерации машинного кода. Это платформонезависимый, строго типизированный язык с гибкими возможностями, подходящий для описания программ на уровне близком к ассемблеру, но с более высоким уровнем абстракции.

---

### Основные особенности LLVM IR

1. **Платформонезависимость**: LLVM IR не зависит от архитектуры процессора.
2. **Строгая типизация**: Все операции выполняются с явно указанными типами данных.
3. **Регистровая архитектура**: Вся работа идет с виртуальными регистрами.
4. **SSA (Static Single Assignment)**: Каждому регистру присваивается значение только один раз.

---

### Типы данных в LLVM IR

#### 1. **Примитивные типы**:
- `void` — отсутствие возвращаемого значения.
- `iN` — целые числа, где `N` — размер в битах (например, `i1`, `i32`, `i64`).
- `float` — числа с плавающей точкой (32-битные).
- `double` — числа с плавающей точкой двойной точности (64-битные).
- `half` — половинная точность (16 бит).
- `x86_fp80`, `fp128`, `ppc_fp128` — расширенные форматы.

#### 2. **Агрегатные типы**:
- `array [N x <type>]` — массив из N элементов типа `<type>`.
- `struct {<type1>, <type2>, ...}` — структура с полями различных типов.
- `vector <N x <type>>` — вектор из N элементов типа `<type>` (используется для SIMD).

#### 3. **Указатели**:
- `<type>*` — указатель на тип `<type>`.

#### 4. **Функциональные типы**:
- `retType (argType1, argType2, ...)` — функция с возвращаемым типом `retType` и аргументами типов `argType1`, `argType2` и так далее.

---

### Виды инструкций LLVM IR

LLVM IR имеет около 50 типов инструкций. Рассмотрим основные:

#### 1. **Арифметические инструкции**:
- `add`, `sub`, `mul`, `sdiv` (знаковое деление), `udiv` (беззнаковое деление).
```llvm
%result = add i32 %a, %b
```

#### 2. **Логические инструкции**:
- `and`, `or`, `xor`, `shl` (сдвиг влево), `lshr` (логический сдвиг вправо).
```llvm
%result = and i32 %a, %b
```

#### 3. **Инструкции сравнения**:
- `icmp` (целочисленное сравнение), `fcmp` (сравнение чисел с плавающей точкой).
```llvm
%cmp = icmp eq i32 %a, %b  ; %a == %b
```

#### 4. **Инструкции ветвления**:
- `br` (безусловный или условный переход).
```llvm
br label %block   ; безусловный переход
br i1 %cond, label %if_true, label %if_false   ; условный переход
```

#### 5. **Инструкции работы с памятью**:
- `alloca` — выделение памяти на стеке.
- `load` — загрузка значения из памяти.
- `store` — сохранение значения в память.
```llvm
%ptr = alloca i32
store i32 42, i32* %ptr
%val = load i32, i32* %ptr
```

#### 6. **Инструкции возврата**:
- `ret` — завершение функции с возвратом значения.
```llvm
ret i32 0
```

#### 7. **Инструкции вызова функций**:
- `call` — вызов функции.
```llvm
%result = call i32 @sum(i32 %a, i32 %b)
```

---

### Базовые блоки (Basic Blocks)

**Базовый блок (Basic Block)** — это последовательность инструкций LLVM IR, которая:
1. Выполняется линейно от начала до конца.
2. Завершается инструкцией управления потоком (`br`, `ret`).

Пример базового блока:
```llvm
entry:
  %0 = add i32 %a, %b
  br label %next_block
```

Каждый базовый блок имеет:
- **Имя**: Метка (например, `entry`, `next_block`).
- **Список инструкций**: Инструкции выполняются в порядке сверху вниз.

---

### Ветвления

LLVM IR поддерживает два типа ветвлений:
1. **Безусловное (`br`)**:
```llvm
br label %next_block
```

2. **Условное (`br i1 <cond>, label <if_true>, label <if_false>`)**:
```llvm
br i1 %cond, label %if_true, label %if_false
```

Пример условного ветвления:
```llvm
entry:
  %cmp = icmp eq i32 %a, %b
  br i1 %cmp, label %if_true, label %if_false

if_true:
  ret i32 1

if_false:
  ret i32 0
```

---

### SSA (Static Single Assignment)

**SSA (Static Single Assignment)** — это форма представления кода, в которой каждой переменной присваивается значение только один раз. Для работы SSA в LLVM используются виртуальные регистры, а ветвления используют **PHI-функции** для выбора значений из разных путей.

Пример:
```llvm
entry:
  br i1 %cond, label %if_true, label %if_false

if_true:
  %val1 = add i32 %a, 1
  br label %merge

if_false:
  %val2 = sub i32 %a, 1
  br label %merge

merge:
  %val = phi i32 [ %val1, %if_true ], [ %val2, %if_false ]
```

- **PHI-функция**: `%val = phi i32 [ %val1, %if_true ], [ %val2, %if_false ]`.
  Она выбирает значение, исходя из того, из какого блока пришел поток выполнения.
